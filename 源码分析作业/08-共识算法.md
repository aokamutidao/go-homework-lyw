# 08 - 共识算法 (Ethash/PoS)

> 返回: [[Go-Ethereum 核心功能与架构设计研究作业]] | 上一章: [[07-EVM执行层]] | 下一章: [[09-实践验证指南]]

## 8.1 共识算法概述

以太坊经历了从 **PoW (工作量证明)** 到 **PoS (权益证明)** 的共识机制转变。

```
以太坊共识演进:

├── Frontier (2015)     - Ethash PoW
├── Homestead (2016)    - 稳定版 Ethash
├── Metropolis (2017)   - EIP 增强
├── Istanbul (2019)     - 难度炸弹延迟
├── London (2021)       - EIP-1559
├── Paris/The Merge (2022) - 转向 PoS
└── Shanghai (2023)     - 完整 PoS 功能
```

## 8.2 Ethash (PoW)

### 算法原理

```
Ethash 算法流程:

┌─────────────────────────────────────────────────────────┐
│  输入: 区块头 + Nonce                                   │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│  1. 混合函数 (Mix Function)                             │
│     - 计算数据集索引                                    │
│     - 从数据集读取 128 字节                             │
│     - Mix = F(cached[i], ...)                          │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│  2. 哈希计算                                            │
│     - Keccak256(Mix)                                   │
│     - 获得 32 字节结果                                  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│  3. 难度验证                                            │
│     - result < target / difficulty                      │
│     - 如果成立: 找到有效的 Nonce                        │
│     - 否则: 重试                                        │
└─────────────────────────────────────────────────────────┘
```

### Dagger-Hashimoto 特点

```
Ethash 设计目标:

1. ASIC 抵抗
   ├── 需要大量内存
   ├── 内存带宽受限
   └── GPU 友好

2. 轻量级验证
   ├── 只需要小数据集
   ├── 验证快速
   └── 适用于轻节点

3. 难度调整
   ├── 目标出块时间 ~13-14 秒
   ├── 难度根据算力调整
   └── 难度炸弹 (Ice Age)
```

### 数据集结构

```
数据集层次:

1. 种子 (Seed)
   └── Keccak256(区块头)
   └── 每 30000 块更新

2. 缓存 (Cache)
   └── 从种子生成
   └── 16MB (高 DAG 阶段: 32MB)
   └── 只需要缓存即可验证

3. 数据集 (Dataset)
   └── 从缓存生成
   └── 1GB (高 DAG 阶段: 2GB)
   └── 矿工需要完整数据集
```

### 源码实现

```go
// consensus/ethash/consensus.go

type Ethash struct {
    cacheDir string
    caches   lru.Cache
    datasets lru.Cache

    // 共识配置
    config   *params.Config
    powHash  common.Hash
    difficulty *big.Int
}

// 验证区块头
func (ethash *Ethash) VerifyHeader(chain consensus.ChainHeaderReader, header *types.Header, seal bool) error {
    // 1. 验证难度
    if header.Difficulty.Cmp(calcDifficulty(chain, header.Number, header.Time, header.Parent, chain.Config()) != 0 {
        return fmt.Errorf("invalid difficulty")
    }

    // 2. 验证 Nonce (如果需要)
    if seal {
        if err := ethash.verifySeal(header); err != nil {
            return err
        }
    }

    return nil
}

// 验证工作量证明
func (ethash *Ethash) verifySeal(header *types.Header) error {
    // 1. 计算 MixHash
    digest, err := ethash.compute(header)
    if err != nil {
        return err
    }

    // 2. 验证 MixHash 与 header 中的匹配
    if !bytes.Equal(digest, header.MixDigest.Bytes()) {
        return ErrInvalidMixHash
    }

    // 3. 验证 Nonce
    if !ethash.validate(header, digest) {
        return ErrInvalidNonce
    }

    return nil
}
```

## 8.3 PoS (权益证明)

### 合并后架构

```
                    PoS 共识架构
    ┌─────────────────────────────────────────┐
│                   信标链 (Beacon Chain)      │
│  ├── 验证者管理                            │
│  ├── 区块提议                              │
│  ├── 区块验证                              │
│  └── 最终性保证                            │
└────────────────────────────────────────────┘
                    │
                    ▼
┌────────────────────────────────────────────┐
│                   执行层 (Execution Layer)  │
│  ├── 交易执行                              │
│  ├── 状态更新                              │
│  └── EVM 执行                              │
└────────────────────────────────────────────┘
```

### 验证者机制

```
验证者职责:

1. 质押 (Stake)
   ├── 最低质押: 32 ETH
   ├── 获得验证者密钥
   └── 加入验证者队列

2. 区块提议 (Proposing)
   ├── 每 12 秒一个槽 (Slot)
   ├── 每个时期 (Epoch) 32 个槽
   ├── 随机选择提议者
   └── 获得交易费用和小费

3. 区块认证 (Attesting)
   ├── 对区块投票
   ├── 参与 Casper FFG
   └── 获得奖励

4. 惩罚 (Slashing)
   ├── 双签惩罚
   ├── 离线惩罚
   └── 罚没机制
```

### Casper FFG

```
                    Casper FFG 最终性
    ┌─────────────────────────────────────────┐
│                                              │
│  概念:                                       │
│  ├── Justification (证明)                   │
│  │   └── 收集 2/3 验证者投票                │
│  │                                          │
│  └── Finality (最终性)                      │
│      └── 连续两个检查点获得超多数            │
│                                              │
│  检查点链:                                   │
│  epoch ─┬── checkpoint ──> checkpoint ──> checkpoint
│         │                │                │
│         └─ 2/3 投票 ────│── 2/3 投票 ────│
│                        └─ 最终确认 ───────┘
│                                              │
└─────────────────────────────────────────────┘
```

### 共识源码

```go
// consensus/consensus.go

type Consensus interface {
    // 验证区块头
    VerifyHeader(chain ChainHeaderReader, header *types.Header, seal bool) error

    // 验证区块
    VerifyUncles(chain ChainHeaderReader, block *types.Block) error

    // 准备区块头
    Prepare(chain ChainHeaderReader, header *types.Header) error

    // 提议区块
    Seal(chain ChainHeaderReader, block *types.Block, results chan<- *types.Block) error

    // 验证密封
    SealHash(header *types.Header) common.Hash

    // 验证区块
    VerifySeal(chain ChainHeaderReader, header *types.Header) error

    // 计算难度
    CalcDifficulty(chain ChainHeaderReader, time uint64, parent *types.Header) *big.Int
}
```

## 8.4 其他共识算法

### Clique (PoA)

```
                    Clique 共识
    ┌─────────────────────────────────────────┐
│                                              │
│  特点:                                       │
│  ├── 授权证明 (Proof of Authority)          │
│  ├── 固定验证者集合                          │
│  ├── 快速出块                                │
│  └── 适用于测试网络和私有链                  │
│                                              │
│  验证者轮换:                                 │
│  ├── 每个区块轮流提议                        │
│  ├── 签名验证                               │
│  └── 阻止验证者                              │
│                                              │
└─────────────────────────────────────────────┘
```

### Istanbul (PoA)

```
                    Istanbul BFT
    ┌─────────────────────────────────────────┐
│                                              │
│  特点:                                       │
│  ├── 基于 PBFT                              │
│  ├── 容错: f = (n-1)/3                      │
│  ├── 快速最终性                             │
│  └── 用于企业以太坊                         │
│                                              │
│  流程:                                       │
│  ├── PRE-PREPARE: 提议者发送区块            │
│  ├── PREPARE: 验证者签名                    │
│  ├── COMMIT: 收集 2f+1 PREPARE              │
│  └── FINAL: 收集 2f+1 COMMIT                │
│                                              │
└─────────────────────────────────────────────┘
```

## 8.5 难度计算

```go
// consensus/ethash/consensus.go

func calcDifficulty(chain consensus.ChainHeaderReader, time uint64, number uint64, parent *types.Header, config *params.ChainConfig) *big.Int {
    // 创世区块
    if number == 0 {
        return parent.Difficulty
    }

    // 计算时间差
    delta := time - parent.Time

    // 难度炸弹
    bombDelay := getBombDelay(config)
    if number >= bombDelay {
        // 指数增长
        exp := number/bombDelay - (bombDelay-1)
        if exp > 0 {
            bombFactor := new(big.Int).Exp(big.NewInt(2), exp, nil)
            delta.Add(delta, bombFactor)
        }
    }

    // 根据时间差调整
    if delta < 0 {
        // 出块太快，增加难度
        return new(big.Int).Add(parent.Difficulty, new(big.Int).Div(parent.Difficulty, diffInertia))
    } else {
        // 出块太慢，减少难度
        return new(big.Int).Sub(parent.Difficulty, new(big.Int).Div(parent.Difficulty, diffInertia))
    }
}
```

## 8.6 挖矿流程

```
                    挖矿流程
    ┌─────────────────────────────────────────┐
│                                              │
│  1. 准备区块                                │
│  ├── 收集交易池中的交易                     │
│  ├── 排序 (按 Gas 价格)                     │
│  ├── 构建区块                              │
│  └── 准备区块头                            │
│                                              │
│  2. 计算工作量                              │
│  ├── 循环尝试 Nonce                        │
│  ├── 计算 MixHash                          │
│  └── 验证难度                              │
│                                              │
│  3. 找到有效 Nonce                         │
│  ├── 广播区块                              │
│  └── 更新本地区块链                        │
│                                              │
└─────────────────────────────────────────────┘
```

---

**下一步**: 查看 [[09-实践验证指南]] 进行编译和运行验证
